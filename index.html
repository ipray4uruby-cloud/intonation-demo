<script>
    // ===== 공통: 탭 전환 =====
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabPanels = {
      live: document.getElementById('tab-live'),
      practice: document.getElementById('tab-practice')
    };
    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset.tab;
        tabButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        Object.keys(tabPanels).forEach(key => {
          tabPanels[key].classList.toggle('hidden', key !== target);
        });
      });
    });

    // ===== 공통: F0 계산 함수 (개선됨) =====
    function autoCorrelate(buf, sr, floor = 75, ceil = 400) {
      const N = buf.length;
      let mean = 0;
      for (let i = 0; i < N; i++) mean += buf[i];
      mean /= N;

      // 평균 제거 + 해닝 윈도우
      for (let i = 0; i < N; i++) {
        buf[i] = (buf[i] - mean) * (0.5 - 0.5 * Math.cos(2 * Math.PI * i / (N - 1)));
      }

      // RMS 계산 (소리 크기 체크)
      let rms = 0;
      for (let i = 0; i < N; i++) rms += buf[i] * buf[i];
      rms = Math.sqrt(rms / N);
      
      // [수정 포인트 1] 감도 임계값을 0.01 -> 0.002로 낮춤 (작은 목소리도 감지)
      if (rms < 0.002) return 0;

      const maxLag = Math.floor(sr / floor);
      const minLag = Math.floor(sr / ceil);

      const xcorr = (lag) => {
        let s = 0;
        for (let i = 0; i < N - lag; i++) s += buf[i] * buf[i + lag];
        return s / (N - lag);
      };

      let bestLag = -1, best = 0;
      for (let lag = minLag; lag <= maxLag; lag++) {
        const c = xcorr(lag);
        if (c > best) { best = c; bestLag = lag; }
      }
      
      // [수정 포인트 2] 상관계수 임계값을 조금 더 너그럽게 조정 (0.1 -> 0.08)
      if (bestLag < 0 || best < 0.08) return 0;

      const c1 = xcorr(bestLag - 1), c2 = xcorr(bestLag), c3 = xcorr(bestLag + 1);
      const denom = (c1 - 2 * c2 + c3);
      let shift = 0;
      if (Math.abs(denom) > 1e-6) shift = 0.5 * (c1 - c3) / denom;
      return sr / (bestLag + shift);
    }

    // ===== 공통: 그래프 그리기 =====
    const c = document.getElementById('c');
    const g = c.getContext('2d');
    const livePoints = [];
    const modelPoints = [];
    const userPoints = [];
    const maxPoints = 1000;

    function getFloor() {
      return +document.getElementById('floor').value || 75;
    }
    function getCeil() {
      return +document.getElementById('ceil').value || 400;
    }

    function mapF0(f, fmin, fmax) {
      const clamped = Math.max(fmin, Math.min(fmax, f));
      const r = (clamped - fmin) / (fmax - fmin);
      return 244 - r * 220; 
    }

    function drawSeries(points, color, floor, ceil) {
      const visible = points.slice(-maxPoints);
      if (!visible.length) return;
      g.strokeStyle = color;
      g.lineWidth = 2; // 선 두께 살짝 증가
      g.beginPath();
      let started = false;
      for (let i = 0; i < visible.length; i++) {
        const f0 = visible[i];
        // 0Hz(무음) 구간은 선을 끊어서 그림
        if (f0 <= 0) { 
          started = false; 
          continue; 
        }
        
        const x = 48 + (i / Math.max(visible.length - 1, 1)) * 1136;
        const y = mapF0(f0, floor, ceil);
        
        if (!started) { g.moveTo(x, y); started = true; }
        else { g.lineTo(x, y); }
      }
      g.stroke();
      g.lineWidth = 1;
    }

    function draw() {
      g.clearRect(0, 0, c.width, c.height);

      // 틀
      g.strokeStyle = "#eee";
      g.beginPath();
      g.moveTo(48, 16);
      g.lineTo(48, 244);
      g.lineTo(1184, 244);
      g.stroke();

      const floor = getFloor();
      const ceil = getCeil();

      [floor, (floor + ceil) / 2, ceil].forEach(t => {
        const y = mapF0(t, floor, ceil);
        g.strokeStyle = "#eee";
        g.beginPath();
        g.moveTo(48, y);
        g.lineTo(1184, y);
        g.stroke();
        g.fillStyle = "#666";
        g.font = "12px system-ui";
        g.fillText(Math.round(t) + " Hz", 8, y - 2);
      });

      // 데이터 시리즈
      drawSeries(modelPoints, "#888888", floor, ceil); 
      drawSeries(userPoints, "#e65b5b", floor, ceil);  
      drawSeries(livePoints, "#0a74da", floor, ceil);  

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    // ===== 실시간 모드 (수정됨) =====
    let audioCtxLive = null;
    let sourceLive = null;
    let processorLive = null;
    let streamLive = null;

    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const nowEl = document.getElementById('now');

    async function startLive() {
      if (audioCtxLive) return; 
      try {
        streamLive = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (e) {
        alert("마이크 권한이 필요합니다. (또는 HTTPS 환경인지 확인하세요)");
        console.error(e);
        return;
      }

      audioCtxLive = new (window.AudioContext || window.webkitAudioContext)();
      
      // [수정 포인트 3] AudioContext가 suspended 상태라면 강제로 깨움 (가장 중요!)
      if (audioCtxLive.state === 'suspended') {
        await audioCtxLive.resume();
      }

      sourceLive = audioCtxLive.createMediaStreamSource(streamLive);
      processorLive = audioCtxLive.createScriptProcessor(2048, 1, 1);
      
      sourceLive.connect(processorLive);
      // processorLive를 destination에 연결해야 크롬에서 작동함 (소리는 안 나게 됨)
      processorLive.connect(audioCtxLive.destination);

      processorLive.onaudioprocess = (e) => {
        const inbuf = e.inputBuffer.getChannelData(0);
        // 처리 속도를 위해 매번 새 배열을 복사
        const tmp = new Float32Array(inbuf); 
        const f0 = autoCorrelate(tmp, audioCtxLive.sampleRate, getFloor(), getCeil());
        
        livePoints.push(f0 > 0 ? f0 : 0);
        if (livePoints.length > 5000) livePoints.shift();
        
        nowEl.textContent = "현재 F0: " + (f0 ? Math.round(f0) + " Hz" : "-- Hz");
      };

      startBtn.disabled = true;
      stopBtn.disabled = false;
    }

    function stopLive() {
      if (processorLive) {
        processorLive.disconnect();
        processorLive.onaudioprocess = null;
        processorLive = null;
      }
      if (sourceLive) {
        sourceLive.disconnect();
        sourceLive = null;
      }
      if (streamLive) {
        streamLive.getTracks().forEach(t => t.stop());
        streamLive = null;
      }
      if (audioCtxLive) {
        audioCtxLive.close();
        audioCtxLive = null;
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
      nowEl.textContent = "현재 F0: -- Hz";
    }

    startBtn.addEventListener('click', startLive);
    stopBtn.addEventListener('click', stopLive);

    // ===== 문장 연습 모드 (기존 유지) =====
    const sentenceDefs = {
      "nugu_yn":  { file: "audio/nugu_yn.wav",  label: "누구 만나요? (판정)" },
      "nugu_wh":  { file: "audio/nugu_wh.wav",  label: "누구 만나요? (설명)" },
      "eodi_yn":  { file: "audio/eodi_yn.wav",  label: "어디 가요? (판정)" },
      "eodi_wh":  { file: "audio/eodi_wh.wav",  label: "어디 가요? (설명)" },
      "eonje_yn": { file: "audio/eonje_yn.wav", label: "언제 와요? (판정)" },
      "eonje_wh": { file: "audio/eonje_wh.wav", label: "언제 와요? (설명)" },
      "mwo_yn":   { file: "audio/mwo_yn.wav",   label: "뭐 해요? (판정)" },
      "mwo_wh":   { file: "audio/mwo_wh.wav",   label: "뭐 해요? (설명)" }
    };

    const sentenceBuffers = {}; 
    const sentBtns = document.querySelectorAll('.sent-btn');
    let currentSentKey = null;

    async function loadSentenceBuffer(key) {
      if (!sentenceDefs[key]) return null;
      if (sentenceBuffers[key]) return sentenceBuffers[key];

      const def = sentenceDefs[key];
      try {
        const resp = await fetch(def.file);
        if (!resp.ok) throw new Error("File not found");
        const arrayBuf = await resp.arrayBuffer();
        const tmpCtx = new (window.AudioContext || window.webkitAudioContext)();
        const buffer = await tmpCtx.decodeAudioData(arrayBuf);
        tmpCtx.close();
        sentenceBuffers[key] = buffer;
        return buffer;
      } catch (e) {
        alert("모범 발화 파일을 불러오지 못했습니다: " + def.file);
        console.error(e);
        return null;
      }
    }

    async function updateModelF0(key) {
      const buffer = await loadSentenceBuffer(key);
      if (!buffer) return;
      const data = buffer.getChannelData(0);
      const sr = buffer.sampleRate;
      const size = 2048;
      const hop = 512;
      const tmp = new Float32Array(size);
      modelPoints.length = 0;

      const floor = getFloor();
      const ceil = getCeil();

      for (let pos = 0; pos + size < data.length; pos += hop) {
        for (let i = 0; i < size; i++) tmp[i] = data[pos + i];
        // 모범 발화 분석 시에는 항상 새 복사본 전달
        const f0 = autoCorrelate(new Float32Array(tmp), sr, floor, ceil);
        modelPoints.push(f0 > 0 ? f0 : 0);
        if (modelPoints.length > 5000) break;
      }
    }

    sentBtns.forEach(btn => {
      btn.addEventListener('click', async () => {
        const key = btn.dataset.sent;
        currentSentKey = key;
        sentBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        userPoints.length = 0; 
        await updateModelF0(key);
      });
    });

    const btnPlayModel = document.getElementById('btn-play-model');
    btnPlayModel.addEventListener('click', async () => {
      if (!currentSentKey) {
        alert("먼저 연습할 문장을 선택해 주세요.");
        return;
      }
      const buffer = await loadSentenceBuffer(currentSentKey);
      if (!buffer) return;
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      src.connect(ctx.destination);
      src.start();
      src.onended = () => ctx.close();
    });

    // 연습 녹음 (여기도 Resume 추가 및 RMS 동일 적용)
    let pracCtx = null;
    let pracSource = null;
    let pracProcessor = null;
    let pracStream = null;

    const btnPracStart = document.getElementById('btn-prac-start');
    const btnPracStop = document.getElementById('btn-prac-stop');

    async function startPracticeRecording() {
      if (!currentSentKey) {
        alert("먼저 연습할 문장을 선택해 주세요.");
        return;
      }
      if (pracCtx) return;

      try {
        pracStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (e) {
        alert("마이크 권한이 필요합니다.");
        return;
      }
      pracCtx = new (window.AudioContext || window.webkitAudioContext)();
      
      // [수정 포인트 4] 연습 모드에서도 AudioContext 깨우기
      if (pracCtx.state === 'suspended') {
        await pracCtx.resume();
      }

      pracSource = pracCtx.createMediaStreamSource(pracStream);
      pracProcessor = pracCtx.createScriptProcessor(2048, 1, 1);
      pracSource.connect(pracProcessor);
      pracProcessor.connect(pracCtx.destination);

      userPoints.length = 0;

      pracProcessor.onaudioprocess = (e) => {
        const inbuf = e.inputBuffer.getChannelData(0);
        const tmp = new Float32Array(inbuf);
        const f0 = autoCorrelate(tmp, pracCtx.sampleRate, getFloor(), getCeil());
        userPoints.push(f0 > 0 ? f0 : 0);
        if (userPoints.length > 5000) userPoints.shift();
      };

      btnPracStart.disabled = true;
      btnPracStop.disabled = false;
    }

    function stopPracticeRecording() {
      if (pracProcessor) {
        pracProcessor.disconnect();
        pracProcessor.onaudioprocess = null;
        pracProcessor = null;
      }
      if (pracSource) {
        pracSource.disconnect();
        pracSource = null;
      }
      if (pracStream) {
        pracStream.getTracks().forEach(t => t.stop());
        pracStream = null;
      }
      if (pracCtx) {
        pracCtx.close();
        pracCtx = null;
      }
      btnPracStart.disabled = false;
      btnPracStop.disabled = true;
    }

    btnPracStart.addEventListener('click', startPracticeRecording);
    btnPracStop.addEventListener('click', stopPracticeRecording);
  </script>
