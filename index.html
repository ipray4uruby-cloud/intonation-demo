<!doctype html>
<html lang="ko">
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>실시간 억양(START–STOP 후 전체 분석)</title>
<style>
  :root { --fg:#111; --muted:#666; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif; margin:16px; color:var(--fg);}
  h1{font-size:18px;margin:0 0 8px}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin:10px 0}
  button{padding:9px 14px;border:1px solid #ccc;border-radius:10px;background:#fafafa;cursor:pointer}
  button[disabled]{opacity:.5;cursor:not-allowed}
  input[type=number]{width:86px}
  #c{width:100%;height:260px;border:1px solid #e2e2e2;border-radius:12px;background:#fff}
  #status{color:var(--muted)}
</style>

<h1>억양(F0) 곡선 최종 확인인억양h1>
<div class="row">
  <button id="start">Start</button>
  <button id="stop" disabled>Stop</button>
  <button id="reset" disabled>Reset</button>
  <!-- CSV 다운로드 / 공유 버튼 추가 -->
  <button id="download" disabled>CSV 다운로드</button>
</div>

<!-- 설정값( Floor / Ceiling / Smoothing )은 숨김 -->
<div class="row" style="display:none">
  <label>Floor(Hz)
    <input id="floor" type="number" value="75" min="40" max="200">
  </label>
  <label>Ceiling(Hz)
    <input id="ceil" type="number" value="400" min="200" max="800">
  </label>
  <label>Smoothing
    <input id="smooth" type="number" value="5" min="1" max="21" step="2">
  </label>
</div>
<canvas id="c" width="1200" height="260"></canvas>
<div class="row"><div id="now">F0: -- Hz</div><small id="status">준비 완료</small></div>

<script>
let mediaStream, mediaRecorder, chunks=[], audioCtx;
const startBtn = document.getElementById('start');
const stopBtn  = document.getElementById('stop');
const resetBtn = document.getElementById('reset');
const downloadBtn = document.getElementById('download');
const c = document.getElementById('c'), g = c.getContext('2d');

// ★ 프레임/홉 크기: 여기서 HOP_MS = 17으로 설정
const FRAME_MS = 30;
const HOP_MS   = 17;

function setStatus(t){ document.getElementById('status').textContent = " · " + t; }

async function ensureAudioContext(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if(audioCtx.state === 'suspended') { try{ await audioCtx.resume(); }catch(e){} }
  return audioCtx;
}

// ===== Pitch tracking (autocorrelation) =====
function hannWindow(N){ const w=new Float32Array(N); for(let i=0;i<N;i++) w[i]=0.5-0.5*Math.cos(2*Math.PI*i/(N-1)); return w; }
const ACF_WINDOW = hannWindow(2048);

function f0_from_frame(buf, sr, floor, ceil){
  const N = buf.length;
  let mean=0; for(let i=0;i<N;i++) mean += buf[i]; mean/=N;
  let rms=0;
  for(let i=0;i<N;i++){
    const v=(buf[i]-mean)*ACF_WINDOW[i%ACF_WINDOW.length];
    rms+=v*v;
    buf[i]=v;
  }
  rms = Math.sqrt(rms/N);
  if(rms < 0.005) return 0; // 감도: 원래 값 유지

  const minLag = Math.floor(sr/ceil);
  const maxLag = Math.floor(sr/floor);
  let bestLag=-1, best=0;

  // normalized autocorrelation
  let denom0=0; for(let i=0;i<N;i++) denom0 += buf[i]*buf[i];
  for(let lag=minLag; lag<=maxLag; lag++){
    let s=0, denom1=0;
    for(let i=0;i<N-lag;i++){
      const a=buf[i], b=buf[i+lag];
      s+=a*b; denom1+=b*b;
    }
    const nccf = (denom1>1e-9)? s/Math.sqrt(denom0*denom1) : 0;
    if(nccf > best){ best=nccf; bestLag=lag; }
  }
  if(bestLag<0 || best<0.3) return 0; // NCCF 임계값도 그대로

  // parabolic interpolation around bestLag
  const ac=(lag)=>{
    let s=0; for(let i=0;i<N-lag;i++) s+=buf[i]*buf[i+lag]; return s;
  };
  const c1=ac(bestLag-1), c2=ac(bestLag), c3=ac(bestLag+1);
  const denom=(c1-2*c2+c3); let shift=0;
  if(Math.abs(denom)>1e-6) shift=0.5*(c1-c3)/denom;

  return sr/(bestLag+shift);
}

function medianSmooth(arr, k=5){
  if(k<2) return arr;
  const h=Math.floor(k/2), out=new Array(arr.length);
  for(let i=0;i<arr.length;i++){
    const s=Math.max(0,i-h), e=Math.min(arr.length,i+h+1);
    const slice=arr.slice(s,e).filter(v=>v>0).sort((a,b)=>a-b);
    out[i] = slice.length ? slice[Math.floor(slice.length/2)] : 0;
  }
  return out;
}

function trackPitch(signal, sr, floor, ceil, frameMs=FRAME_MS, hopMs=HOP_MS){
  const frame = Math.round(sr*frameMs/1000),
        hop   = Math.round(sr*hopMs/1000);
  const out=[]; const buf = new Float32Array(frame);
  for(let start=0; start+frame<=signal.length; start+=hop){
    buf.set(signal.subarray(start,start+frame));
    out.push(f0_from_frame(buf.slice(0), sr, floor, ceil));
  }
  return out;
}

// ===== Drawing =====
function drawAxes(floor, ceil){
  g.clearRect(0,0,c.width,c.height);
  g.strokeStyle="#eee"; g.lineWidth=1;
  g.beginPath(); g.moveTo(48,16); g.lineTo(48,244); g.lineTo(1184,244); g.stroke();
  [floor, Math.round((floor+ceil)/2), ceil].forEach(t=>{
    const y=mapF0(t,floor,ceil);
    g.beginPath(); g.moveTo(48,y); g.lineTo(1184,y); g.stroke();
    g.fillStyle="#666"; g.font="12px system-ui"; g.fillText(t+" Hz", 8, y-2);
  });
}

function drawContour(f0s, floor, ceil, color="#0a74da"){
  drawAxes(floor, ceil);
  const n=f0s.length;
  g.strokeStyle=color; g.lineWidth=2; g.beginPath();
  let started=false;
  for(let i=0;i<n;i++){
    const f0=f0s[i]; if(f0<=0){ started=false; continue; }
    const x=48 + (i/Math.max(n-1,1))*1136;
    const y=mapF0(f0,floor,ceil);
    if(!started){ g.moveTo(x,y); started=true; } else { g.lineTo(x,y); }
  }
  g.stroke();
}

function mapF0(f,fmin,fmax){
  const clamped=Math.max(fmin,Math.min(fmax,f));
  const r=(clamped-fmin)/(fmax-fmin);
  return 244 - r*220;
}

// ===== CSV 저장용 전역 변수 =====
let lastF0s = [];
let lastFloorHz = null;
let lastCeilHz  = null;
let lastSmoothK = null;

// ===== UI flow =====
startBtn.onclick = async () => {
  try{
    await ensureAudioContext();
    mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {channelCount:1, echoCancellation:false, noiseSuppression:false, autoGainControl:false}
    });
  }catch(e){
    alert("마이크 권한이 필요합니다.\n(HTTPS 환경에서만 작동)");
    return;
  }
  chunks.length = 0;
  const mime = MediaRecorder.isTypeSupported('audio/webm;codecs=opus') ? 'audio/webm;codecs=opus'
               : MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4'
               : '';
  mediaRecorder = new MediaRecorder(mediaStream, mime?{mimeType:mime}:{});
  mediaRecorder.ondataavailable = (ev)=>{ if(ev.data && ev.data.size>0) chunks.push(ev.data); };
  mediaRecorder.onstart = ()=> setStatus("녹음 중… 문장을 말하세요.");
  mediaRecorder.start();

  startBtn.disabled = true;
  stopBtn.disabled = false;
  resetBtn.disabled = true;
  downloadBtn.disabled = true;
  lastF0s = [];
  document.getElementById('now').textContent = "F0: -- Hz";
  drawAxes(+floor.value, +ceil.value);
};

stopBtn.onclick = async () => {
  stopBtn.disabled = true;
  if(!mediaRecorder){ return; }
  setStatus("처리 중…(1초 내)");
  mediaRecorder.onstop = async ()=>{
    const blob = new Blob(chunks);
    chunks.length = 0;

    const arrayBuf = await blob.arrayBuffer();
    const ctx = await ensureAudioContext();
    const audioBuf = await ctx.decodeAudioData(arrayBuf.slice(0));

    const ch = audioBuf.numberOfChannels ? audioBuf.getChannelData(0) : new Float32Array(arrayBuf.byteLength/4);
    const signal = new Float32Array(ch.length);
    let peak = 0;
    for(let i=0;i<ch.length;i++){
      const v=Math.max(-1,Math.min(1,ch[i]));
      peak=Math.max(peak,Math.abs(v));
      signal[i]=v;
    }
    if(peak>0){
      const s=1/peak;
      for(let i=0;i<signal.length;i++) signal[i]*=s;
    }

    const floorHz = +document.getElementById('floor').value || 75;
    const ceilHz  = +document.getElementById('ceil').value  || 400;
    const k       = +document.getElementById('smooth').value;

    const f0sRaw  = trackPitch(signal, audioBuf.sampleRate, floorHz, ceilHz, FRAME_MS, HOP_MS);
    const f0s     = medianSmooth(f0sRaw, k);

    const last = f0s.findLast
      ? (f0s.findLast(v=>v>0)||0)
      : (function(){ for(let i=f0s.length-1;i>=0;i--) if(f0s[i]>0) return f0s[i]; return 0; })();
    document.getElementById('now').textContent = "F0: " + (last? Math.round(last) : "--") + " Hz";

    drawContour(f0s, floorHz, ceilHz);
    setStatus("완료. 다시 녹음하려면 Reset → Start");
    resetBtn.disabled = false;

    lastF0s     = f0s;
    lastFloorHz = floorHz;
    lastCeilHz  = ceilHz;
    lastSmoothK = k;
    downloadBtn.disabled = (f0s.length === 0);
  };
  mediaRecorder.stop();
  if(mediaStream){ mediaStream.getTracks().forEach(t=>t.stop()); mediaStream=null; }
};

resetBtn.onclick = ()=>{
  drawAxes(+floor.value, +ceil.value);
  document.getElementById('now').textContent = "F0: -- Hz";
  setStatus("준비 완료");
  startBtn.disabled=false;
  stopBtn.disabled=true;
  resetBtn.disabled=true;
  downloadBtn.disabled=true;
  lastF0s = [];
};

// ★ CSV 다운로드 + 가능하면 시스템 공유창 열기
downloadBtn.onclick = async () => {
  if (!lastF0s || lastF0s.length === 0) {
    alert("먼저 녹음을 하고 Stop을 눌러 곡선을 생성해 주세요.");
    return;
  }

  const lines = [];
  const meta = `# frame_ms=${FRAME_MS}, hop_ms=${HOP_MS}, floor_hz=${lastFloorHz}, ceil_hz=${lastCeilHz}, smooth=${lastSmoothK}`;
  lines.push(meta);
  lines.push("time_sec,f0_hz");

  for (let i = 0; i < lastF0s.length; i++) {
    const t  = (i * HOP_MS / 1000).toFixed(3);
    const f0 = lastF0s[i] > 0 ? lastF0s[i].toFixed(2) : "";
    lines.push(`${t},${f0}`);
  }

  const csv = lines.join("\n");
  const blob = new Blob([csv], { type: "text/csv" });
  const ts = new Date().toISOString().replace(/[:.]/g, "-");
  const filename = `intonation_${ts}.csv`;

  // 1) Web Share API로 공유 시도 (카톡/메일 등)
  try {
    const file = new File([blob], filename, { type: "text/csv" });

    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({
        title: "Intonation CSV",
        text: "웹앱에서 생성한 억양(F0) 데이터입니다.",
        files: [file]
      });
      return; // 공유 성공/취소 후 여기서 종료
    }
  } catch (e) {
    console.warn("공유 기능 사용 불가 또는 취소됨, 다운로드로 대체:", e);
  }

  // 2) 공유 안 되면 다운로드로 폴백
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

// 초기 축
drawAxes(+floor.value, +ceil.value);
</script>
</html>


