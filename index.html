<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>í•œêµ­ì–´ ì–µì–‘ ì›¹ì•± (ë°ëª¨)</title>
  <style>
    :root {
      --fg: #222;
      --blue: #0a74da;
      --red: #e65b5b;
      --gray: #888888;
    }
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      margin: 16px;
      color: var(--fg);
    }
    h1 {
      font-size: 22px;
      margin: 4px 0 12px;
    }
    h2 {
      font-size: 18px;
      margin: 16px 0 8px;
    }
    h3 {
      font-size: 15px;
      margin: 8px 0 4px;
    }
    #c {
      width: 100%;
      height: 260px;
      border: 1px solid #ddd;
      border-radius: 12px;
      margin: 8px 0 6px;
      background: #fff;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 6px 0;
      align-items: center;
    }
    .tabs {
      display: inline-flex;
      border-radius: 999px;
      background: #f3f4f6;
      padding: 3px;
      margin-bottom: 8px;
    }
    .tab-btn {
      border: none;
      background: transparent;
      padding: 6px 14px;
      border-radius: 999px;
      cursor: pointer;
      font-size: 14px;
    }
    .tab-btn.active {
      background: #2563eb;
      color: #fff;
    }
    button {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid #d1d5db;
      background: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }
    button.primary {
      background: #2563eb;
      border-color: #2563eb;
      color: #fff;
    }
    input[type=number] {
      width: 80px;
      padding: 4px 6px;
      border-radius: 6px;
      border: 1px solid #d1d5db;
      font-size: 14px;
    }
    label {
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 13px;
      margin-top: 4px;
    }
    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
      display: inline-block;
    }
    .dot.live { background: var(--blue); }
    .dot.model { background: var(--gray); }
    .dot.user { background: var(--red); }

    .hidden { display: none; }

    .sentence-group {
      border-radius: 12px;
      border: 1px solid #e5e7eb;
      padding: 8px 10px;
      margin-bottom: 8px;
    }
    .sentence-group .sent-btn {
      margin: 2px 4px 2px 0;
      font-size: 13px;
      padding: 4px 10px;
    }
    .sent-btn.active {
      background: #111827;
      color: #fff;
      border-color: #111827;
    }

    p {
      font-size: 13px;
      margin: 4px 0;
      line-height: 1.4;
    }

    @media (max-width: 600px) {
      #c { height: 220px; }
      h1 { font-size: 20px; }
    }
  </style>
</head>
<body>
  <h1>ğŸ¤ í•œêµ­ì–´ ì–µì–‘ ì›¹ì•± (ë°ëª¨)</h1>

  <!-- íƒ­ -->
  <div class="tabs">
    <button class="tab-btn active" data-tab="live">ì‹¤ì‹œê°„ F0 ë³´ê¸°</button>
    <button class="tab-btn" data-tab="practice">ë¬¸ì¥ ì—°ìŠµ ëª¨ë“œ</button>
  </div>

  <!-- ê³µí†µ ê·¸ë˜í”„ -->
  <canvas id="c" width="1232" height="260"></canvas>

  <div class="legend">
    <span class="legend-item"><span class="dot live"></span> ì‹¤ì‹œê°„ F0 (Start/Stop)</span>
    <span class="legend-item"><span class="dot model"></span> ëª¨ë²” ë°œí™” F0 (ì—°ìŠµ ëª¨ë“œ)</span>
    <span class="legend-item"><span class="dot user"></span> ë‚´ ë°œí™” F0 (ì—°ìŠµ ëª¨ë“œ)</span>
  </div>

  <div class="row">
    <span id="now">í˜„ì¬ F0: -- Hz</span>
  </div>
  <div class="row">
    <label>Floor(Hz)
      <input id="floor" type="number" value="75" min="30" max="300" />
    </label>
    <label>Ceiling(Hz)
      <input id="ceil" type="number" value="400" min="150" max="800" />
    </label>
  </div>

  <!-- ì‹¤ì‹œê°„ íƒ­ -->
  <div id="tab-live">
    <h2>â‘  ì‹¤ì‹œê°„ ì–µì–‘(F0) ê³¡ì„  ë³´ê¸°</h2>
    <div class="row">
      <button id="start" class="primary">Start</button>
      <button id="stop" disabled>Stop</button>
    </div>
    <p>
      Start ë²„íŠ¼ì„ ëˆ„ë¥´ê³  ë¸Œë¼ìš°ì €ì˜ ë§ˆì´í¬ ê¶Œí•œì„ í—ˆìš©í•œ ë’¤ ë§í•´ ë³´ì„¸ìš”.  
      íŒŒë€ ì„ ì´ ë§í•˜ëŠ” ë™ì•ˆì˜ ì‹¤ì‹œê°„ F0 ê³¡ì„ ì…ë‹ˆë‹¤.
    </p>
  </div>

  <!-- ë¬¸ì¥ ì—°ìŠµ íƒ­ -->
  <div id="tab-practice" class="hidden">
    <h2>â‘¡ ë¬¸ì¥ ì—°ìŠµ ëª¨ë“œ</h2>
    <p>ì—°ìŠµí•  ë¬¸ì¥(ì˜ë¬¸ì‚¬ + íŒì •/ì„¤ëª…)ì„ ì„ íƒí•œ ë’¤ ëª¨ë²” ë°œí™” ë“£ê¸° â†’ ë‚´ ë°œí™” ë…¹ìŒ ìˆœì„œë¡œ ì—°ìŠµí•©ë‹ˆë‹¤.</p>

    <div class="sentence-group">
      <h3>ëˆ„êµ¬</h3>
      <button class="sent-btn" data-sent="nugu_yn">ëˆ„êµ¬ ë§Œë‚˜ìš”? (íŒì •)</button>
      <button class="sent-btn" data-sent="nugu_wh">ëˆ„êµ¬ ë§Œë‚˜ìš”? (ì„¤ëª…)</button>
    </div>
    <div class="sentence-group">
      <h3>ì–´ë””</h3>
      <button class="sent-btn" data-sent="eodi_yn">ì–´ë”” ê°€ìš”? (íŒì •)</button>
      <button class="sent-btn" data-sent="eodi_wh">ì–´ë”” ê°€ìš”? (ì„¤ëª…)</button>
    </div>
    <div class="sentence-group">
      <h3>ì–¸ì œ</h3>
      <button class="sent-btn" data-sent="eonje_yn">ì–¸ì œ ì™€ìš”? (íŒì •)</button>
      <button class="sent-btn" data-sent="eonje_wh">ì–¸ì œ ì™€ìš”? (ì„¤ëª…)</button>
    </div>
    <div class="sentence-group">
      <h3>ë­</h3>
      <button class="sent-btn" data-sent="mwo_yn">ë­ í•´ìš”? (íŒì •)</button>
      <button class="sent-btn" data-sent="mwo_wh">ë­ í•´ìš”? (ì„¤ëª…)</button>
    </div>

    <div class="row">
      <button id="btn-play-model">ëª¨ë²” ë°œí™” ë“£ê¸°</button>
      <button id="btn-prac-start" class="primary">ë‚´ ë°œí™” ë…¹ìŒ ì‹œì‘</button>
      <button id="btn-prac-stop" disabled>ë…¹ìŒ ì¢…ë£Œ</button>
    </div>
    <p>
      íšŒìƒ‰ ì„ : ëª¨ë²” ë°œí™” F0 / ë¹¨ê°„ ì„ : ë‚´ ë°œí™” F0 (ì—°ìŠµ ê²°ê³¼)<br>
      ì—¬ëŸ¬ ë²ˆ ë…¹ìŒí•˜ë©´ ìµœê·¼ ì—°ìŠµ ê²°ê³¼ë§Œ ë¹¨ê°„ ì„ ìœ¼ë¡œ ë‚¨ìŠµë‹ˆë‹¤.
    </p>
  </div>

  <script>
    // =========================
    //  íƒ­ ì „í™˜
    // =========================
    const tabButtons = document.querySelectorAll('.tab-btn');
    const tabPanels = {
      live: document.getElementById('tab-live'),
      practice: document.getElementById('tab-practice')
    };
    tabButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset.tab;
        tabButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        Object.keys(tabPanels).forEach(key => {
          tabPanels[key].classList.toggle('hidden', key !== target);
        });
      });
    });

    // =========================
    //  ê³µí†µ: F0 ê³„ì‚° (ver1.0ê³¼ ë™ì¼)
    // =========================
    function autoCorrelate(buf, sr, floor = 75, ceil = 400) {
      const N = buf.length;
      let mean = 0;
      for (let i = 0; i < N; i++) mean += buf[i];
      mean /= N;

      // í‰ê·  ì œê±° + í•´ë‹ ìœˆë„ìš°
      for (let i = 0; i < N; i++) {
        buf[i] = (buf[i] - mean) * (0.5 - 0.5 * Math.cos(2 * Math.PI * i / (N - 1)));
      }

      // ì—ë„ˆì§€ ë„ˆë¬´ ì‘ìœ¼ë©´ 0 ë°˜í™˜
      let rms = 0;
      for (let i = 0; i < N; i++) rms += buf[i] * buf[i];
      rms = Math.sqrt(rms / N);
      if (rms < 0.01) return 0;

      const maxLag = Math.floor(sr / floor);
      const minLag = Math.floor(sr / ceil);

      const xcorr = (lag) => {
        let s = 0;
        for (let i = 0; i < N - lag; i++) s += buf[i] * buf[i + lag];
        return s / (N - lag);
      };

      let bestLag = -1, best = 0;
      for (let lag = minLag; lag <= maxLag; lag++) {
        const c = xcorr(lag);
        if (c > best) { best = c; bestLag = lag; }
      }
      if (bestLag < 0 || best < 0.1) return 0;

      const c1 = xcorr(bestLag - 1), c2 = xcorr(bestLag), c3 = xcorr(bestLag + 1);
      const denom = (c1 - 2 * c2 + c3);
      let shift = 0;
      if (Math.abs(denom) > 1e-6) shift = 0.5 * (c1 - c3) / denom;
      return sr / (bestLag + shift);
    }

    // =========================
    //  ê³µí†µ: ê·¸ë˜í”„ ê·¸ë¦¬ê¸°
    // =========================
    const c = document.getElementById('c');
    const g = c.getContext('2d');

    const livePoints = [];   // íŒŒë€ì„  (ì‹¤ì‹œê°„)
    const modelPoints = [];  // íšŒìƒ‰ì„  (ëª¨ë²” ë°œí™”)
    const userPoints = [];   // ë¹¨ê°„ì„  (ë‚´ ë°œí™”)
    const maxPoints = 5000;

    function getFloor() {
      const v = +document.getElementById('floor').value;
      return v > 0 ? v : 75;
    }
    function getCeil() {
      const v = +document.getElementById('ceil').value;
      return v > 0 ? v : 400;
    }

    function mapF0(f, fmin, fmax) {
      const clamped = Math.max(fmin, Math.min(fmax, f));
      const r = (clamped - fmin) / (fmax - fmin);
      // ìº”ë²„ìŠ¤ ì•ˆì—ì„œ ìœ„(ê³ ìŒ) ~ ì•„ë˜(ì €ìŒ) ìœ„ì¹˜
      return 244 - r * 220;
    }

    function drawSeries(points, color, floor, ceil) {
      const visible = points.slice(-maxPoints);
      if (!visible.length) return;
      g.strokeStyle = color;
      g.lineWidth = 2;
      g.beginPath();
      let started = false;
      for (let i = 0; i < visible.length; i++) {
        const f0 = visible[i];
        if (f0 <= 0) { // ë¬´ìŒ êµ¬ê°„ì€ ì„  ëŠê¸°
          started = false;
          continue;
        }
        const x = 48 + (i / Math.max(visible.length - 1, 1)) * 1136;
        const y = mapF0(f0, floor, ceil);
        if (!started) { g.moveTo(x, y); started = true; }
        else { g.lineTo(x, y); }
      }
      g.stroke();
      g.lineWidth = 1;
    }

    function draw() {
      g.clearRect(0, 0, c.width, c.height);

      const floor = getFloor();
      const ceil = getCeil();

      // í‹€
      g.strokeStyle = "#eee";
      g.beginPath();
      g.moveTo(48, 16);
      g.lineTo(48, 244);
      g.lineTo(1184, 244);
      g.stroke();

      // ê¸°ì¤€ì„  (floor / mid / ceil)
      [floor, (floor + ceil) / 2, ceil].forEach(t => {
        const y = mapF0(t, floor, ceil);
        g.strokeStyle = "#eee";
        g.beginPath();
        g.moveTo(48, y);
        g.lineTo(1184, y);
        g.stroke();
        g.fillStyle = "#666";
        g.font = "12px system-ui";
        g.fillText(Math.round(t) + " Hz", 8, y - 2);
      });

      // ì„¸ ì‹œë¦¬ì¦ˆ ê·¸ë¦¬ê¸°
      drawSeries(modelPoints, "#888888", floor, ceil);
      drawSeries(userPoints, "#e65b5b", floor, ceil);
      drawSeries(livePoints, "#0a74da", floor, ceil);

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);

    // =========================
    //  ì‹¤ì‹œê°„ F0 ëª¨ë“œ
    // =========================
    let audioCtxLive = null;
    let sourceLive = null;
    let processorLive = null;
    let streamLive = null;

    const startBtn = document.getElementById('start');
    const stopBtn  = document.getElementById('stop');
    const nowEl    = document.getElementById('now');

    async function startLive() {
      if (audioCtxLive) return; // ì´ë¯¸ ì‹¤í–‰ ì¤‘
      try {
        streamLive = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (e) {
        alert("ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.");
        console.error(e);
        return;
      }

      audioCtxLive = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtxLive.state === "suspended") {
        await audioCtxLive.resume();
      }

      sourceLive = audioCtxLive.createMediaStreamSource(streamLive);
      processorLive = audioCtxLive.createScriptProcessor(2048, 1, 1);

      sourceLive.connect(processorLive);
      processorLive.connect(audioCtxLive.destination);

      processorLive.onaudioprocess = (e) => {
        const inbuf = e.inputBuffer.getChannelData(0);
        const tmp = new Float32Array(inbuf); // ë³µì‚¬ë³¸
        const f0 = autoCorrelate(tmp, audioCtxLive.sampleRate, getFloor(), getCeil());

        livePoints.push(f0 > 0 ? f0 : 0);
        if (livePoints.length > maxPoints) livePoints.shift();

        nowEl.textContent = "í˜„ì¬ F0: " + (f0 > 0 ? Math.round(f0) + " Hz" : "-- Hz");
      };

      startBtn.disabled = true;
      stopBtn.disabled = false;
    }

    function stopLive() {
      if (processorLive) {
        processorLive.disconnect();
        processorLive.onaudioprocess = null;
        processorLive = null;
      }
      if (sourceLive) {
        sourceLive.disconnect();
        sourceLive = null;
      }
      if (streamLive) {
        streamLive.getTracks().forEach(t => t.stop());
        streamLive = null;
      }
      if (audioCtxLive) {
        audioCtxLive.close();
        audioCtxLive = null;
      }
      startBtn.disabled = false;
      stopBtn.disabled = true;
      nowEl.textContent = "í˜„ì¬ F0: -- Hz";
      livePoints.length = 0; // í™”ë©´ë„ ì´ˆê¸°í™”
    }

    startBtn.addEventListener('click', startLive);
    stopBtn.addEventListener('click', stopLive);

    // =========================
    //  ë¬¸ì¥ ì—°ìŠµ ëª¨ë“œ
    // =========================
    const sentenceDefs = {
      "nugu_yn":  { file: "audio/nugu_yn.wav",  label: "ëˆ„êµ¬ ë§Œë‚˜ìš”? (íŒì •)" },
      "nugu_wh":  { file: "audio/nugu_wh.wav",  label: "ëˆ„êµ¬ ë§Œë‚˜ìš”? (ì„¤ëª…)" },
      "eodi_yn":  { file: "audio/eodi_yn.wav",  label: "ì–´ë”” ê°€ìš”? (íŒì •)" },
      "eodi_wh":  { file: "audio/eodi_wh.wav",  label: "ì–´ë”” ê°€ìš”? (ì„¤ëª…)" },
      "eonje_yn": { file: "audio/eonje_yn.wav", label: "ì–¸ì œ ì™€ìš”? (íŒì •)" },
      "eonje_wh": { file: "audio/eonje_wh.wav", label: "ì–¸ì œ ì™€ìš”? (ì„¤ëª…)" },
      "mwo_yn":   { file: "audio/mwo_yn.wav",   label: "ë­ í•´ìš”? (íŒì •)" },
      "mwo_wh":   { file: "audio/mwo_wh.wav",   label: "ë­ í•´ìš”? (ì„¤ëª…)" }
    };

    const sentenceBuffers = {};
    const sentBtns = document.querySelectorAll('.sent-btn');
    let currentSentKey = null;

    async function loadSentenceBuffer(key) {
      if (!sentenceDefs[key]) return null;
      if (sentenceBuffers[key]) return sentenceBuffers[key];

      const def = sentenceDefs[key];
      try {
        const resp = await fetch(def.file);
        if (!resp.ok) throw new Error("File not found");
        const arrayBuf = await resp.arrayBuffer();
        const tmpCtx = new (window.AudioContext || window.webkitAudioContext)();
        const buffer = await tmpCtx.decodeAudioData(arrayBuf);
        tmpCtx.close();
        sentenceBuffers[key] = buffer;
        return buffer;
      } catch (e) {
        alert("ëª¨ë²” ë°œí™” íŒŒì¼ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: " + def.file);
        console.error(e);
        return null;
      }
    }

    async function updateModelF0(key) {
      const buffer = await loadSentenceBuffer(key);
      if (!buffer) return;
      const data = buffer.getChannelData(0);
      const sr   = buffer.sampleRate;
      const size = 2048;
      const hop  = 512;
      const tmp  = new Float32Array(size);

      modelPoints.length = 0;

      const floor = getFloor();
      const ceil  = getCeil();

      for (let pos = 0; pos + size < data.length; pos += hop) {
        for (let i = 0; i < size; i++) tmp[i] = data[pos + i];
        const f0 = autoCorrelate(new Float32Array(tmp), sr, floor, ceil);
        modelPoints.push(f0 > 0 ? f0 : 0);
        if (modelPoints.length > maxPoints) break;
      }
    }

    sentBtns.forEach(btn => {
      btn.addEventListener('click', async () => {
        const key = btn.dataset.sent;
        currentSentKey = key;
        sentBtns.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        userPoints.length = 0; // ë‚´ ë°œí™” ê³¡ì„  ì´ˆê¸°í™”
        await updateModelF0(key);
      });
    });

    // ëª¨ë²” ë°œí™” ì¬ìƒ
    const btnPlayModel = document.getElementById('btn-play-model');
    btnPlayModel.addEventListener('click', async () => {
      if (!currentSentKey) {
        alert("ë¨¼ì € ì—°ìŠµí•  ë¬¸ì¥ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.");
        return;
      }
      const buffer = await loadSentenceBuffer(currentSentKey);
      if (!buffer) return;
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      src.connect(ctx.destination);
      src.start();
      src.onended = () => ctx.close();
    });

    // ì—°ìŠµ ë…¹ìŒ
    let pracCtx = null;
    let pracSource = null;
    let pracProcessor = null;
    let pracStream = null;

    const btnPracStart = document.getElementById('btn-prac-start');
    const btnPracStop  = document.getElementById('btn-prac-stop');

    async function startPracticeRecording() {
      if (!currentSentKey) {
        alert("ë¨¼ì € ì—°ìŠµí•  ë¬¸ì¥ì„ ì„ íƒí•´ ì£¼ì„¸ìš”.");
        return;
      }
      if (pracCtx) return;

      try {
        pracStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (e) {
        alert("ë§ˆì´í¬ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤.");
        console.error(e);
        return;
      }

      pracCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (pracCtx.state === "suspended") {
        await pracCtx.resume();
      }

      pracSource = pracCtx.createMediaStreamSource(pracStream);
      pracProcessor = pracCtx.createScriptProcessor(2048, 1, 1);

      pracSource.connect(pracProcessor);
      pracProcessor.connect(pracCtx.destination);

      userPoints.length = 0;

      pracProcessor.onaudioprocess = (e) => {
        const inbuf = e.inputBuffer.getChannelData(0);
        const tmp = new Float32Array(inbuf);
        const f0 = autoCorrelate(tmp, pracCtx.sampleRate, getFloor(), getCeil());
        userPoints.push(f0 > 0 ? f0 : 0);
        if (userPoints.length > maxPoints) userPoints.shift();
      };

      btnPracStart.disabled = true;
      btnPracStop.disabled = false;
    }

    function stopPracticeRecording() {
      if (pracProcessor) {
        pracProcessor.disconnect();
        pracProcessor.onaudioprocess = null;
        pracProcessor = null;
      }
      if (pracSource) {
        pracSource.disconnect();
        pracSource = null;
      }
      if (pracStream) {
        pracStream.getTracks().forEach(t => t.stop());
        pracStream = null;
      }
      if (pracCtx) {
        pracCtx.close();
        pracCtx = null;
      }
      btnPracStart.disabled = false;
      btnPracStop.disabled = true;
    }

    btnPracStart.addEventListener('click', startPracticeRecording);
    btnPracStop.addEventListener('click', stopPracticeRecording);
  </script>
</body>
</html>
